"""Integration tests for Transaction endpoints."""

from uuid import uuid4

import pytest


@pytest.mark.asyncio
class TestTransactionIntegration:
    """Integration tests for transaction operations."""

    async def test_create_transaction_stores_in_database(self, authenticated_client):
        """Test that creating a transaction actually stores it in the database."""
        txn_id = f"TXN-INT-{uuid4().hex[:8]}"
        reference = f"REF-INT-{uuid4().hex[:8]}"

        # Create transaction
        create_response = await authenticated_client.post(
            "/api/v1/transactions",
            json={
                "transaction_id": txn_id,
                "reference": reference,
                "bank": "BANESCO",
                "transaction_type": "TRANSACTION",
                "customer_full_name": "Test Customer",
                "customer_phone": "04241234567",
                "customer_national_id": "V12345678",
                "concept": "Test transaction",
            },
        )

        assert create_response.status_code == 201
        transaction_uuid = create_response.json()["id"]

        # Verify it can be retrieved
        get_response = await authenticated_client.get(
            f"/api/v1/transactions/{transaction_uuid}"
        )

        assert get_response.status_code == 200
        retrieved = get_response.json()
        assert retrieved["id"] == transaction_uuid
        assert retrieved["transaction_id"] == txn_id
        assert retrieved["reference"] == reference

    async def test_update_transaction_modifies_database(self, authenticated_client):
        """Test that updating a transaction modifies the database record."""
        txn_id = f"TXN-UPD-{uuid4().hex[:8]}"
        reference = f"REF-UPD-{uuid4().hex[:8]}"

        # Create initial transaction
        create_response = await authenticated_client.post(
            "/api/v1/transactions",
            json={
                "transaction_id": txn_id,
                "reference": reference,
                "bank": "BANESCO",
                "transaction_type": "TRANSACTION",
                "customer_full_name": "Original Name",
                "customer_phone": "04241234567",
                "customer_national_id": "V12345678",
                "concept": "Original concept",
            },
        )

        transaction_uuid = create_response.json()["id"]

        # Update transaction
        update_response = await authenticated_client.post(
            "/api/v1/transactions",
            json={
                "transaction_id": txn_id,  # Same ID
                "reference": reference,
                "bank": "BANESCO",
                "transaction_type": "TRANSACTION",
                "customer_full_name": "Updated Name",
                "customer_phone": "04241234567",
                "customer_national_id": "V12345678",
                "concept": "Updated concept",
            },
        )

        assert update_response.status_code == 201
        updated = update_response.json()

        # UUID should remain the same
        assert updated["id"] == transaction_uuid
        # But content should be updated
        assert updated["customer_full_name"] == "Updated Name"
        assert updated["concept"] == "Updated concept"

        # Verify update persisted
        get_response = await authenticated_client.get(
            f"/api/v1/transactions/{transaction_uuid}"
        )
        persisted = get_response.json()
        assert persisted["customer_full_name"] == "Updated Name"

    async def test_list_transactions_reflects_database_state(
        self, authenticated_client
    ):
        """Test that listing transactions reflects actual database state."""
        # Create multiple transactions
        created_ids = []
        for i in range(3):
            response = await authenticated_client.post(
                "/api/v1/transactions",
                json={
                    "transaction_id": f"TXN-LIST-{uuid4().hex[:8]}-{i}",
                    "reference": f"REF-LIST-{uuid4().hex[:8]}-{i}",
                    "bank": "BANESCO",
                    "transaction_type": "TRANSACTION",
                    "customer_full_name": f"Customer {i}",
                    "customer_phone": "04241234567",
                    "customer_national_id": "V12345678",
                    "concept": f"Test {i}",
                },
            )
            created_ids.append(response.json()["id"])

        # List transactions
        list_response = await authenticated_client.get("/api/v1/transactions")

        assert list_response.status_code == 200
        list_data = list_response.json()

        # All created transactions should be in the list
        listed_ids = [t["id"] for t in list_data["transactions"]]
        for created_id in created_ids:
            assert created_id in listed_ids

    async def test_query_by_different_keys(self, authenticated_client):
        """Test querying transaction by UUID, reference, and transaction_id."""
        txn_id = f"TXN-QUERY-{uuid4().hex[:8]}"
        reference = f"REF-QUERY-{uuid4().hex[:8]}"

        # Create transaction
        create_response = await authenticated_client.post(
            "/api/v1/transactions",
            json={
                "transaction_id": txn_id,
                "reference": reference,
                "bank": "BANESCO",
                "transaction_type": "TRANSACTION",
                "customer_full_name": "Query Test",
                "customer_phone": "04241234567",
                "customer_national_id": "V12345678",
                "concept": "Test",
            },
        )

        transaction_uuid = create_response.json()["id"]

        # Query by UUID
        uuid_response = await authenticated_client.get(
            f"/api/v1/transactions/{transaction_uuid}"
        )
        assert uuid_response.status_code == 200
        assert uuid_response.json()["id"] == transaction_uuid

        # Query by reference
        ref_response = await authenticated_client.get(
            f"/api/v1/transactions/reference/{reference}"
        )
        assert ref_response.status_code == 200
        assert ref_response.json()["id"] == transaction_uuid

        # Query by transaction_id
        txn_id_response = await authenticated_client.get(
            f"/api/v1/transactions/external/{txn_id}"
        )
        assert txn_id_response.status_code == 200
        assert txn_id_response.json()["id"] == transaction_uuid

    async def test_pagination_works_correctly(self, authenticated_client):
        """Test that pagination actually limits and offsets results."""
        # Create 5 transactions
        for i in range(5):
            await authenticated_client.post(
                "/api/v1/transactions",
                json={
                    "transaction_id": f"TXN-PAGE-{uuid4().hex[:8]}-{i}",
                    "reference": f"REF-PAGE-{uuid4().hex[:8]}-{i}",
                    "bank": "BANESCO",
                    "transaction_type": "TRANSACTION",
                    "customer_full_name": f"Customer {i}",
                    "customer_phone": "04241234567",
                    "customer_national_id": "V12345678",
                    "concept": "Test",
                },
            )

        # Get first page (limit 2)
        page1_response = await authenticated_client.get(
            "/api/v1/transactions?limit=2&offset=0"
        )
        page1 = page1_response.json()
        assert len(page1["transactions"]) <= 2
        assert page1["limit"] == 2
        assert page1["offset"] == 0

        # Get second page (limit 2, offset 2)
        page2_response = await authenticated_client.get(
            "/api/v1/transactions?limit=2&offset=2"
        )
        page2 = page2_response.json()
        assert len(page2["transactions"]) <= 2
        assert page2["offset"] == 2

        # Pages should have different transactions (if there are enough)
        if len(page1["transactions"]) > 0 and len(page2["transactions"]) > 0:
            page1_ids = {t["id"] for t in page1["transactions"]}
            page2_ids = {t["id"] for t in page2["transactions"]}
            # At least some transactions should be different
            assert not page1_ids.issubset(page2_ids) or not page2_ids.issubset(
                page1_ids
            )
